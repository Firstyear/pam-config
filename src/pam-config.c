/* Copyright (C) 2006, 2007 Thorsten Kukuk
   Author: Thorsten Kukuk <kukuk@thkukuk.de>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <getopt.h>

#include <pam-config.h>

#include "supported-modules.h"

int debug = 0;
char *confdir;
char *conf_account = NULL;
char *conf_account_pc = NULL;
char *conf_auth = NULL;
char *conf_auth_pc = NULL;
char *conf_password = NULL;
char *conf_password_pc = NULL;
char *conf_session = NULL;
char *conf_session_pc = NULL;

static void
print_usage (FILE *stream, const char *program)
{
  fprintf (stream, _("Usage: %s -a|-c|-d [...]\n"),
           program);
}

/* Print the version information.  */
static void
print_version (const char *program, const char *years)
{
  fprintf (stdout, "%s (%s) %s\n", program, PACKAGE, VERSION);
  fprintf (stdout, _("\
Copyright (C) %s Thorsten Kukuk.\n\
This is free software; see the source for copying conditions.  There is NO\n\
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
"), years);
  /* fprintf (stdout, _("Written by %s.\n"), "Thorsten Kukuk"); */
}

static void
print_error (const char *program)
{
  fprintf (stderr,
           _("Try `%s --help' or `%s --usage' for more information.\n"),
           program, program);
}

static void
print_help (const char *program)
{
  print_usage (stdout, program);
  fprintf (stdout, _("%s - create PAM config files\n\n"), program);

  fputs (_("  -a, --add         Add options/PAM modules\n"), stdout);
  fputs (_("  -c, --create      Create new configuration\n"), stdout);
  fputs (_("  -d, --delete      Remove options/PAM modules\n"), stdout);
  fputs (_("      --confdir     Use a custom configuration directory\n"),
	 stdout);
  fputs (_("      --initialize  Convert old config and create new one\n"),
	 stdout);
  fputs (_("      --service config  Service to modify config of\n"),
	 stdout);
  fputs (_("      --update      Read current config and write them new\n"),
         stdout);
  fputs (_("  -q, --query       Query for installed modules and options\n"),
	 stdout);
  fputs (_("      --help        Give this help list\n"), stdout);
  fputs (_("  -u, --usage       Give a short usage message\n"), stdout);
  fputs (_("  -v, --version     Print program version\n"), stdout);
}

static void
list_modules (pam_module_t **module_list)
{
  while (*module_list != NULL) {
    fprintf (stdout, "\t%s\n",(*module_list)->name);
    module_list++;
  };
}

static int
check_symlink (const char *old, const char *new)
{
  if (access (new, F_OK) == -1)
    {
      if (symlink (old, new) != 0)
	{
	  fprintf (stderr,
		   _("Error activating %s (%m)\n"), new);
	      fprintf (stderr,
		       _("New config from %s is not in use!\n"),
		       old);
	      return 1;
	}
      return 0;
    }
  else
    {
      char buf[1024];

      memset (&buf, 0, sizeof (buf));
      if (readlink (new, buf, sizeof (buf)) <= 0 ||
          strcmp (old, buf) != 0)
	{
	  fprintf (stderr,
		   _("File %s is no symlink to %s.\n"), new, old);
	  fprintf (stderr,
		   _("New config from %s is is not in use!\n"),
		   old);
	  return 1;
	}
      return 0;
    }
}

/* if 'file' exists, make backup from original file. symlink
 * autogenerated one to the original name.
 */
static int
relink (const char *file, const char *file_pc, const char *file_bak)
{
  if (0 == access (file, F_OK))
  {
    if (link (file, file_bak) != 0 ||
	unlink (file) != 0 ||
	symlink (file_pc, file) != 0)
    {
      fprintf (stderr,
	  _("Error activating %s (%m)\n"), file);
      fprintf (stderr,
	  _("New config from %s is not in use!\n"), file_pc);
      return 1;
    }
  }
  else
  {
    fprintf (stderr, _("WARNING: file '%s' not found. Omitting backup.\n"), file);
    if (symlink (file_pc, file) != 0)
    {
      fprintf (stderr,
	  _("Error activating %s (%m)\n"), file);
      fprintf (stderr,
	  _("New config from %s is not in use!\n"), file_pc);
      return 1;
    }
  }
  return 0;
}

char *gl_service = NULL;

int
main (int argc, char *argv[])
{
  const char *program = "pam-config";
  int m_add = 0, m_create = 0, m_delete = 0, m_init = 0, m_update = 0;
  int m_query = 0;
  int force = 0;
  int opt_val = 1;
  int retval = 0;
  option_set_t *opt_set;

  setlocale(LC_ALL, "");
  bindtextdomain(PACKAGE, LOCALEDIR);
  textdomain(PACKAGE);

  openlog (program, LOG_ODELAY | LOG_PID, LOG_AUTHPRIV);
  if (argc < 2)
    {
      print_error (program);
      return 1;
    }
  else if (strcmp (argv[1], "--debug") == 0)
    {
      debug = 1;
      argc--;
      argv++;
    }

  if (strcmp (argv[1], "--confdir") == 0)
  {
	  confdir = argv[2];
	  if(confdir[0] != '/')
	  {
		  print_error(program);
		  return 1;
	  }
      argc--;
      argv++;
      argc--;
      argv++;
  }
  else
  {
	  confdir = strdup(CONFDIR);
  }

  if (asprintf (&conf_account, "%s/pam.d/common-account", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_account_pc, "%s/pam.d/common-account-pc", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_auth, "%s/pam.d/common-auth", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_auth_pc, "%s/pam.d/common-auth-pc", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_password, "%s/pam.d/common-password", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_password_pc, "%s/pam.d/common-password-pc", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_session, "%s/pam.d/common-session", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }
  if (asprintf (&conf_session_pc, "%s/pam.d/common-session-pc", confdir) < 0)
  {
	  print_error (program);
	  return 1;
  }


  if (argc < 2)
    {
      print_error (program);
      return 1;
    }
  if (strncmp (argv[1], "--service", 9) == 0)
    {
      if (argv[1][9] == '='){
	gl_service = &argv[1][10];
      }
      else
	{
	  if ( argc < 3 || argv[2][0] == '-')
	    {
	      print_error (program);
	      return 1;
	    }
	  gl_service = argv[2];
	  argc--;
	  argv++;
	}
      argc--;
      argv++;
    }
  if (argc < 2)
    {
      print_error (program);
      return 1;
    }

  if (strcmp (argv[1], "-a") == 0 || strcmp (argv[1], "--add") == 0)
    {
      m_add = 1;
      argc--;
      argv++;
    }
  else if (strcmp (argv[1], "-c") == 0 || strcmp (argv[1], "--create") == 0)
    {
      if (gl_service)
	{
	  print_error (program);
	  return 1;
	}
      m_create = 1;
      argc--;
      argv++;
    }
  else if (strcmp (argv[1], "-d") == 0 || strcmp (argv[1], "--delete") == 0)
    {
      m_delete = 1;
      argc--;
      argv++;
      opt_val = 0;
    }
  else if (strcmp (argv[1], "--initialize") == 0)
    {
      m_init = 1;

      argc--;
      argv++;

      if (argc > 1 || gl_service)
	{
	  print_error (program);
	  return 1;
	}

      /* Load old /etc/security/{pam_unix2,pam_pwcheck}.conf
	 files and delete them afterwards.  */
      if ( load_obsolete_conf (common_module_list) != 0)
      {
	fprintf (stderr, _( "WARNING: Couldn't load old config files.\n"));
      }

      if (load_config (conf_account, ACCOUNT, common_module_list, 1) != 0)
	{
	load_old_config_error:
	  fprintf (stderr, _("\nCouldn't load config file, aborted!\n"));
	  return 1;
	}
      if (load_config (conf_auth, AUTH, common_module_list, 1) != 0)
	goto load_old_config_error;
      if (load_config (conf_password, PASSWORD, common_module_list, 1) != 0)
	goto load_old_config_error;
      if (load_config (conf_session, SESSION, common_module_list, 1) != 0)
	goto load_old_config_error;
    }
  else if (strcmp (argv[1], "--update") == 0)
    {
      m_update = 1;
      argc--;
      argv++;
    }
  else if (strcmp (argv[1], "-q") == 0 || strcmp (argv[1], "--query") == 0)
    {
      m_query = 1;
      argc--;
      argv++;
    }

  if (m_add || m_delete || m_update || m_query)
    {
      if (argc == 1 && !m_update && !m_query)
	{
	  print_error (program);
	  return 1;
	}

      if (!gl_service)
	{
	  if (load_config (conf_account_pc, ACCOUNT, common_module_list, 1) != 0)
	    {
	    load_config_error:
	      fprintf (stderr, _("\nCouldn't load config file, aborted!\n"));
	      return 1;
	    }
	  if (load_config (conf_auth_pc, AUTH, common_module_list, 1) != 0)
	    goto load_config_error;
	  if (load_config (conf_password_pc, PASSWORD, common_module_list, 1) != 0)
	    goto load_config_error;
	  if (load_config (conf_session_pc, SESSION, common_module_list, 1) != 0)
	    goto load_config_error;
	}
      else
	{
	  /* --service option given */
	  char *fname;

	  if (asprintf (&fname, "%s/pam.d/%s", confdir, gl_service) < 0)
	    return 1;

	  if (load_config (fname, ACCOUNT, service_module_list, 0) != 0)
	    {
	    load_config_error2:
	      fprintf (stderr,
		       _("\nCouldn't load config file '%s', aborted!\n"),
		       fname);
	      return 1;
	    }
	  if (load_config (fname, AUTH, service_module_list, 0) != 0)
	    goto load_config_error2;
	  if (load_config (fname, PASSWORD, service_module_list, 0) != 0)
	    goto load_config_error2;
	  if (load_config (fname, SESSION, service_module_list, 0) != 0)
	    goto load_config_error2;
	}
    }
  while (1)
    {
      int c;
      int option_index = 0;
      static struct option common_long_options[] = {
        {"version",                   no_argument,       NULL,  'v' },
        {"usage",                     no_argument,       NULL,  'u' },
        {"force",                     no_argument,       NULL,  'f' },
	{"debug",                     no_argument,       NULL,  254 },
        {"help",                      no_argument,       NULL,  255 },
        {"list-modules",              no_argument,       NULL,  300 },
	{"nullok",                    no_argument,       NULL,  900 },
	{"pam-debug",                 no_argument,       NULL,  901 },
	/* pam_pwcheck */
	{"pwcheck",                   no_argument,       NULL, 1000 },
	{"pwcheck-debug",             no_argument,       NULL, 1001 },
	{"pwcheck-nullok",            no_argument,       NULL, 1002 },
	{"pwcheck-cracklib",          no_argument,       NULL, 1003 },
	{"pwcheck-cracklib-path",     required_argument, NULL, 1004 },
	{"pwcheck-maxlen",            required_argument, NULL, 1005 },
	{"pwcheck-minlen",            required_argument, NULL, 1006 },
	{"pwcheck-tries",             required_argument, NULL, 1007 },
	{"pwcheck-remember",          required_argument, NULL, 1008 },
	{"pwcheck-nisdir",            required_argument, NULL, 1009 },
	{"pwcheck-no_obscure_checks", no_argument,       NULL, 1010 },
	{"pwcheck-enforce_for_root",  no_argument,       NULL, 1011 },
	{"mkhomedir",                 no_argument,       NULL, 1100 },
	{"mkhomedir-debug",           no_argument,       NULL, 1101 },
	{"mkhomedir-silent",          no_argument,       NULL, 1102 },
	{"mkhomedir-umask",           required_argument, NULL, 1103 },
	{"mkhomedir-skel",            required_argument, NULL, 1104 },
	{"limits",                    no_argument,       NULL, 1200 },
	{"limits-debug",              no_argument,       NULL, 1201 },
	{"limits-change_uid",         no_argument,       NULL, 1202 },
	{"limits-utmp_early",         no_argument,       NULL, 1203 },
	{"limits-conf",               required_argument, NULL, 1204 },
        {"env",              no_argument,       NULL, 1300 },
        {"env-debug",        no_argument,       NULL, 1301 },
	{"env-conffile",     required_argument, NULL, 1302 },
	{"env-envfile",      required_argument, NULL, 1303 },
	{"env-readenv",      required_argument, NULL, 1304 },
        {"make",             no_argument,       NULL, 1500 },
        {"make-dir",         no_argument,       NULL, 1501 },
        {"unix2",            no_argument,       NULL, 1600 },
        {"unix2-debug",      no_argument,       NULL, 1601 },
        {"unix2-nullok",     no_argument,       NULL, 1602 },
        {"unix2-trace",      no_argument,       NULL, 1603 },
        {"unix2-call_modules", required_argument, NULL, 1604 },
        {"unix",            no_argument,        NULL, 1700 },
        {"unix-debug",      no_argument,        NULL, 1701 },
        {"unix-audit",      no_argument,        NULL, 1702 },
        {"unix-nullok",     no_argument,        NULL, 1703 },
        {"unix-shadow",     no_argument,        NULL, 1704 },
        {"unix-md5",        no_argument,        NULL, 1705 },
        {"unix-bigcrypt",  no_argument,        NULL, 1706 },
	{"krb5",                  no_argument,       NULL, 1800 },
	{"krb5-debug",            no_argument,       NULL, 1801 },
	{"krb5-minimum_uid",      required_argument, NULL, 1802 },
	{"krb5-ignore_unknown_principals",
	                          no_argument,       NULL, 1803 },
	{"ldap",                  no_argument,       NULL, 1900 },
	{"ldap-debug",            no_argument,       NULL, 1901 },
 	{"ldap-account_only",     no_argument,       NULL, 1902 },
 	{"ccreds",                no_argument,       NULL, 2000 },
	{"pkcs11",                no_argument,       NULL, 2010 },
	{"apparmor",              no_argument,       NULL, 2020 },
	{"nam",                   no_argument,       NULL, 2030 },
        {"cracklib",              no_argument,       NULL, 2100 },
        {"cracklib-debug",        no_argument,       NULL, 2101 },
	{"cracklib-dictpath",     required_argument, NULL, 2102 },
	{"cracklib-retry",        required_argument, NULL, 2103 },
	{"cracklib-minlen",       required_argument, NULL, 2104 },
	{"winbind",               no_argument,       NULL, 2200 },
	{"winbind-debug",         no_argument,       NULL, 2201 },
	{"umask",                 no_argument,       NULL, 2300 },
	{"umask-debug",           no_argument,       NULL, 2301 },
	{"umask-silent",          no_argument,       NULL, 2302 },
	{"umask-usergroups",      no_argument,       NULL, 2303 },
	{"umask-umask",           required_argument, NULL, 2304 },
	{"thinkfinger",           no_argument,       NULL, 2400 },
        {NULL,                    0,                 NULL,    0 }
      };
      static struct option service_long_options[] = {
        {"version",               no_argument,       NULL,  'v' },
        {"usage",                 no_argument,       NULL,  'u' },
        {"force",                 no_argument,       NULL,  'f' },
	{"debug",                 no_argument,       NULL,  254 },
        {"help",                  no_argument,       NULL,  255 },
	{"nullok",                no_argument,       NULL,  900 },
	{"pam-debug",             no_argument,       NULL,  901 },
	{"loginuid",              no_argument,       NULL, 3000 },
        {"loginuid-require_auditd", no_argument,     NULL, 3001 },
        {"lastlog",               no_argument,       NULL, 3050 },
	{"mount",		  no_argument,	     NULL, 3100 },
	{"cryptpass",		  no_argument,	     NULL, 3200 },
	{"cryptpass-password",	  no_argument,	     NULL, 3201 },
	{"ck_connector",	  no_argument,	     NULL, 3300 },
	{"ck_connector-debug",	  no_argument,	     NULL, 3301 },
	{NULL,                    0,                 NULL,    0 }
      };
      if (!gl_service)
	c = getopt_long (argc, argv, "fvu",
			 common_long_options, &option_index);
      else
	c = getopt_long (argc, argv, "fvu",
			 service_long_options, &option_index);

      if (c == (-1))
        break;
      switch (c)
	{
	case 'f':
	  force = 1;
	  break;
	case 900: /* --nullok */
	  {
	    pam_module_t **modptr = common_module_list;

	    while (*modptr != NULL)
	      {
		opt_set = (*modptr)->get_opt_set (*modptr, AUTH);
		opt_set->enable (opt_set, "nullok", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, ACCOUNT);
		opt_set->enable (opt_set, "nullok", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, PASSWORD);
		opt_set->enable (opt_set, "nullok", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, SESSION);
		opt_set->enable (opt_set, "nullok", opt_val);
		++modptr;
	      }
	  }
	  break;
	case 901: /* --pam-debug */
	  {
	    pam_module_t **modptr = common_module_list;

	    while (*modptr != NULL)
	      {
		opt_set = (*modptr)->get_opt_set (*modptr, AUTH);
		opt_set->enable (opt_set, "debug", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, ACCOUNT);
		opt_set->enable (opt_set, "debug", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, PASSWORD);
		opt_set->enable (opt_set, "debug", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, SESSION);
		opt_set->enable (opt_set, "debug", opt_val);

		++modptr;
	      }

	    modptr = service_module_list;

	    while (*modptr != NULL)
	      {
		opt_set = (*modptr)->get_opt_set (*modptr, AUTH);
		opt_set->enable (opt_set, "debug", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, ACCOUNT);
		opt_set->enable (opt_set, "debug", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, PASSWORD);
		opt_set->enable (opt_set, "debug", opt_val);
		opt_set = (*modptr)->get_opt_set (*modptr, SESSION);
		opt_set->enable (opt_set, "debug", opt_val);

		++modptr;
	      }
	  }
	  break;
	/* pam_pwcheck */
	case 1000:
	  if (m_query)
	    print_module_config (common_module_list, "pam_pwcheck.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_pwcheck.so", force) != 0)
		return 1;
	      opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck,
						     PASSWORD);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1001:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1002:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  break;
	case 1003:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "cracklib", opt_val);
	  break;
	case 1004:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "cracklib", opt_val);
	  opt_set->set_opt (opt_set, "cracklib_path", optarg);
	  break;
	case 1005:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  if (m_delete)
	    opt_set->set_opt (opt_set, "maxlen", NULL);
	  else
	    opt_set->set_opt (opt_set, "maxlen", optarg);
	  break;
	case 1006:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  if (m_delete)
	    opt_set->set_opt (opt_set, "minlen", NULL);
	  else
	    opt_set->set_opt (opt_set, "minlen", optarg);
	  break;
	case 1007:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->set_opt (opt_set, "tries", optarg);
	  break;
	case 1008:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->set_opt (opt_set, "remember", optarg);
	  break;
	case 1009:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->set_opt (opt_set, "nisdir", optarg);
	  break;
	case 1010:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "no_obscure_checks", opt_val);
	  break;
	case 1011:
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "enforce_for_root", opt_val);
	  break;
	case 1100:
	  if (m_query)
	    print_module_config (common_module_list,
				 "pam_mkhomedir.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_mkhomedir.so", force) != 0)
		return 1;
	      opt_set = mod_pam_mkhomedir.get_opt_set (&mod_pam_mkhomedir,
						       SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1101:
	  opt_set = mod_pam_mkhomedir.get_opt_set (&mod_pam_mkhomedir,
						   SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1102:
	  opt_set = mod_pam_mkhomedir.get_opt_set (&mod_pam_mkhomedir,
						   SESSION);
	  opt_set->enable (opt_set, "silent", opt_val);
	  break;
	case 1103:
	  opt_set = mod_pam_mkhomedir.get_opt_set (&mod_pam_mkhomedir,
						   SESSION);
	  opt_set->set_opt (opt_set, "umask", optarg);
	  break;
	case 1104:
	  opt_set = mod_pam_mkhomedir.get_opt_set (&mod_pam_mkhomedir,
						   SESSION);
	  opt_set->set_opt (opt_set, "skel", optarg);
	  break;
	case 1200:
	  /* pam_limits.so */
	  if (m_query)
	    print_module_config (common_module_list, "pam_limits.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_limits.so", force) != 0)
		return 1;
	      opt_set = mod_pam_limits.get_opt_set (&mod_pam_limits, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1201:
	  opt_set = mod_pam_limits.get_opt_set (&mod_pam_limits, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1202:
	  opt_set = mod_pam_limits.get_opt_set (&mod_pam_limits, SESSION);
	  opt_set->enable (opt_set, "change_uid", opt_val);
	  break;
	case 1203:
	  opt_set = mod_pam_limits.get_opt_set (&mod_pam_limits, SESSION);
	  opt_set->enable (opt_set, "utmp_early", opt_val);
	  break;
	case 1204:
	  opt_set = mod_pam_limits.get_opt_set (&mod_pam_limits, SESSION);
	  opt_set->set_opt (opt_set, "conv", optarg);
	  break;
	case 1300:
	  /* pam_env.so */
	  if (m_query)
	    print_module_config (common_module_list, "pam_env.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_env.so", force) != 0)
		return 1;
	      /* Remove in every case from auth,
		 else we will have it twice.  */
	      opt_set = mod_pam_env.get_opt_set (&mod_pam_env, AUTH);
	      opt_set->enable (opt_set, "is_enabled", FALSE);
	      opt_set = mod_pam_env.get_opt_set (&mod_pam_env, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1301:
	  opt_set = mod_pam_env.get_opt_set (&mod_pam_env, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1302:
	  opt_set = mod_pam_env.get_opt_set (&mod_pam_env, SESSION);
	  opt_set->set_opt (opt_set, "conffile", optarg);
	  break;
	case 1303:
	  opt_set = mod_pam_env.get_opt_set (&mod_pam_env, SESSION);
	  opt_set->set_opt (opt_set, "envfile", optarg);
	  break;
	case 1304:
	  opt_set = mod_pam_env.get_opt_set (&mod_pam_env, SESSION);
	  opt_set->set_opt (opt_set, "readenv", optarg);
	  break;
	case 1500:
	  /* pam_make.so */
	  if (m_query)
	    print_module_config (common_module_list, "pam_make.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_make.so", force) != 0)
		return 1;
              opt_set = mod_pam_make.get_opt_set (&mod_pam_make, PASSWORD);
              opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1501:
	  opt_set = mod_pam_make.get_opt_set (&mod_pam_make, PASSWORD);
	  opt_set->set_opt (opt_set, "option", optarg);
	  break;
	case 1600:
	  /* use_unix2 */
	  if (m_query)
            print_module_config (common_module_list, "pam_unix2.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_unix2.so", force) != 0)
		return 1;
              opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, ACCOUNT);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, AUTH);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, PASSWORD);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
              opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1601:
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, ACCOUNT);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, AUTH);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1602:
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, ACCOUNT);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, AUTH);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, PASSWORD);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  break;
        case 1603:
	  opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
	  opt_set->enable (opt_set, "trace", opt_val);
          break;
        case 1604:
	  if (m_delete)
	    {
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, ACCOUNT);
	      opt_set->set_opt (opt_set, "call_modules", NULL);
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, AUTH);
	      opt_set->set_opt (opt_set, "call_modules", NULL);
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, PASSWORD);
	      opt_set->set_opt (opt_set, "call_modules", NULL);
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
	      opt_set->set_opt (opt_set, "call_modules", NULL);
	    }
	  else
	    {
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, ACCOUNT);
	      opt_set->set_opt (opt_set, "call_modules", optarg);
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, AUTH);
	      opt_set->set_opt (opt_set, "call_modules", optarg);
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, PASSWORD);
	      opt_set->set_opt (opt_set, "call_modules", optarg);
	      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
	      opt_set->set_opt (opt_set, "call_modules", optarg);
	    }
          break;
	case 1700:
	  /* use_unix */
	  if (m_query)
            print_module_config (common_module_list, "pam_unix.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_unix.so", force) != 0)
		return 1;
              opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
              opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1701:
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1702:
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
	  opt_set->enable (opt_set, "audit", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
	  opt_set->enable (opt_set, "audit", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
	  opt_set->enable (opt_set, "audit", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
	  opt_set->enable (opt_set, "audit", opt_val);
	  break;
	case 1703:
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
	  opt_set->enable (opt_set, "nullok", opt_val);
	  break;
	case 1704:
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
	  opt_set->enable (opt_set, "shadow", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
	  opt_set->enable (opt_set, "shadow", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
	  opt_set->enable (opt_set, "shadow", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
	  opt_set->enable (opt_set, "shadow", opt_val);
	  break;
	case 1705:
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
	  opt_set->enable (opt_set, "md5", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
	  opt_set->enable (opt_set, "md5", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
	  opt_set->enable (opt_set, "md5", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
	  opt_set->enable (opt_set, "md5", opt_val);
	  break;
	case 1706:
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, ACCOUNT);
	  opt_set->enable (opt_set, "bigcrypt", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, AUTH);
	  opt_set->enable (opt_set, "bigcrypt", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, PASSWORD);
	  opt_set->enable (opt_set, "bigcrypt", opt_val);
	  opt_set = mod_pam_unix.get_opt_set (&mod_pam_unix, SESSION);
	  opt_set->enable (opt_set, "bigcrypt", opt_val);
	  break;
	case 1800:
	  /* use_krb5 */
	  if (m_query)
            print_module_config (common_module_list, "pam_krb5.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_krb5.so", force) != 0)
		return 1;
              opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, ACCOUNT);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, AUTH);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, PASSWORD);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, SESSION);
              opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1801:
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, ACCOUNT);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, AUTH);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
        case 1802:
	  if (m_delete)
	    {
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, ACCOUNT);
	      opt_set->set_opt (opt_set, "minimum_uid", NULL);
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, AUTH);
	      opt_set->set_opt (opt_set, "minimum_uid", NULL);
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, PASSWORD);
	      opt_set->set_opt (opt_set, "minimum_uid", NULL);
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, SESSION);
	      opt_set->set_opt (opt_set, "minimum_uid", NULL);
	    }
	  else
	    {
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, ACCOUNT);
	      opt_set->set_opt (opt_set, "minimum_uid", optarg);
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, AUTH);
	      opt_set->set_opt (opt_set, "minimum_uid", optarg);
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, PASSWORD);
	      opt_set->set_opt (opt_set, "minimum_uid", optarg);
	      opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, SESSION);
	      opt_set->set_opt (opt_set, "minimum_uid", optarg);
	    }
          break;
	case 1803:
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, ACCOUNT);
	  opt_set->enable (opt_set, "ignore_unknown_principals", opt_val);
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, AUTH);
	  opt_set->enable (opt_set, "ignore_unknown_principals", opt_val);
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, PASSWORD);
	  opt_set->enable (opt_set, "ignore_unknown_principals", opt_val);
	  opt_set = mod_pam_krb5.get_opt_set (&mod_pam_krb5, SESSION);
	  opt_set->enable (opt_set, "ignore_unknown_principals", opt_val);
	  break;
	case 1900:
	  /* pam_ldap */
	  if (m_query)
            print_module_config (common_module_list, "pam_ldap.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_ldap.so", force) != 0)
		return 1;
              opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, ACCOUNT);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, AUTH);
			  opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, PASSWORD);
			  opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, SESSION);
			  opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 1901:
	  opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, ACCOUNT);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, AUTH);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 1902:
		/* pam_ldap account_only*/
		if (m_query)
			print_module_config (common_module_list, "pam_ldap.so");
		else
		{
			if (!m_delete && check_for_pam_module ("pam_ldap.so", force) != 0)
				return 1;
			opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, ACCOUNT);
			opt_set->enable (opt_set, "is_enabled", opt_val);
			opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, AUTH);
			opt_set->enable (opt_set, "is_enabled", 0);
			opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, PASSWORD);
			opt_set->enable (opt_set, "is_enabled", 0);
			opt_set = mod_pam_ldap.get_opt_set (&mod_pam_ldap, SESSION);
			opt_set->enable (opt_set, "is_enabled", 0);
		}
		break;
	case 2000:
	  /* pam_ccreds */
	  if (m_query)
            print_module_config (common_module_list, "pam_ccreds.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_ccreds.so", force) != 0)
		return 1;
	      opt_set = mod_pam_ccreds.get_opt_set (&mod_pam_ccreds, AUTH);
	      opt_set->enable (opt_set, "is_enabled", TRUE);
	    }
	  break;
	case 2010:
	  /* pam_pkcs11 */
	  if (m_query)
            print_module_config (common_module_list, "pam_pkcs11.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_pkcs11.so", force) != 0)
		return 1;
	      opt_set = mod_pam_ccreds.get_opt_set (&mod_pam_pkcs11, AUTH);
	      opt_set->enable (opt_set, "is_enabled", TRUE);
	    }
	  break;
	case 2020:
	  /* pam_apparmor */
	  if (m_query)
	    print_module_config (common_module_list, "pam_apparmor.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_apparmor.so", force) != 0)
		return 1;

	      opt_set = mod_pam_apparmor.get_opt_set (&mod_pam_apparmor,
						      SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 2030:
	  /* pam_nam.so */
	  if (m_query)
	    print_module_config (common_module_list, "pam_nam.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_nam.so", force) != 0)
		return 1;

	      opt_set = mod_pam_nam.get_opt_set (&mod_pam_nam, ACCOUNT);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	      opt_set = mod_pam_nam.get_opt_set (&mod_pam_nam, AUTH);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	      opt_set = mod_pam_nam.get_opt_set (&mod_pam_nam, PASSWORD);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	      opt_set = mod_pam_nam.get_opt_set (&mod_pam_nam, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 2100:
	  /* pam_cracklib */
	  if (m_query)
	    print_module_config (common_module_list, "pam_cracklib.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_cracklib.so", force) != 0)
		return 1;
	      opt_set = mod_pam_cracklib.get_opt_set (&mod_pam_cracklib,
						      PASSWORD);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 2101:
	  opt_set = mod_pam_cracklib.get_opt_set (&mod_pam_cracklib, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 2102:
	  opt_set = mod_pam_cracklib.get_opt_set (&mod_pam_cracklib, PASSWORD);
	  if (m_delete)
	    opt_set->set_opt (opt_set, "dictpath", NULL);
	  else
	    opt_set->set_opt (opt_set, "dictpath", optarg);
	  break;
	case 2103:
	  opt_set = mod_pam_cracklib.get_opt_set (&mod_pam_cracklib, PASSWORD);
	  if (m_delete)
	    opt_set->set_opt (opt_set, "retry", NULL);
	  else
	    opt_set->set_opt (opt_set, "retry", optarg);
	  break;
	case 2104:
	  opt_set = mod_pam_cracklib.get_opt_set (&mod_pam_cracklib, PASSWORD);
	  if (m_delete)
	    opt_set->set_opt (opt_set, "minlen", NULL);
	  else
	    opt_set->set_opt (opt_set, "minlen", optarg);
	  break;
	case 2200:
	  /* pam_winbind */
	  if (m_query)
            print_module_config (common_module_list, "pam_winbind.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_winbind.so", force) != 0)
		return 1;
              opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind,
						     ACCOUNT);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind,
						     AUTH);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind,
						     PASSWORD);
              opt_set->enable (opt_set, "is_enabled", opt_val);
              opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind,
						     SESSION);
              opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 2201:
	  opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind, ACCOUNT);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind, AUTH);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind, PASSWORD);
	  opt_set->enable (opt_set, "debug", opt_val);
	  opt_set = mod_pam_winbind.get_opt_set (&mod_pam_winbind, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 2300:
	  /* pam_umask.so */
	  if (m_query)
	    print_module_config (common_module_list, "pam_umask.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_umask.so", force) != 0)
		return 1;
	      opt_set = mod_pam_umask.get_opt_set (&mod_pam_umask, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 2301:
	  opt_set = mod_pam_umask.get_opt_set (&mod_pam_umask, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 2302:
	  opt_set = mod_pam_umask.get_opt_set (&mod_pam_umask, SESSION);
	  opt_set->enable (opt_set, "silent", opt_val);
	  break;
	case 2303:
	  opt_set = mod_pam_umask.get_opt_set (&mod_pam_umask, SESSION);
	  opt_set->enable (opt_set, "usergroups", opt_val);
	  break;
	case 2304:
	  opt_set = mod_pam_umask.get_opt_set (&mod_pam_umask, SESSION);
	  opt_set->set_opt (opt_set, "umask", optarg);
	  break;
	case 2400:
	  /* pam_thinkfinger.so */
	  if (m_query)
	    print_module_config (common_module_list, "pam_thinkfinger.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_thinkfinger.so", force) != 0)
		return 1;
	      opt_set = mod_pam_thinkfinger.get_opt_set (&mod_pam_thinkfinger, AUTH);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	  /* From here we have single service modules */
	case 3000:
          /* pam_loginuid.so */
	  if (m_query)
	    print_module_config (service_module_list, "pam_loginuid.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_loginuid.so", force) != 0)
		return 1;
	      opt_set = mod_pam_loginuid.get_opt_set (&mod_pam_loginuid,
						      SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
        case 3001:
	  opt_set = mod_pam_loginuid.get_opt_set (&mod_pam_loginuid, SESSION);
	      opt_set->enable (opt_set, "require_auditd", opt_val);
          break;
	case 3050:
          /* pam_lastlog.so */
	  if (m_query)
	    print_module_config (service_module_list, "pam_lastlog.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_lastlog.so", force) != 0)
		return 1;
	      opt_set = mod_pam_lastlog.get_opt_set (&mod_pam_lastlog,
						     SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	      opt_set->enable (opt_set, "nowtmp", opt_val);
	    }
	  break;
	case 3100:
	  /* pam_mount.so */
	  if (m_query)
	    print_module_config (service_module_list, "pam_mount.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_mount.so", force) != 0)
		return 1;
	      opt_set = mod_pam_mount.get_opt_set (&mod_pam_mount, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 3200:
	  /* pam_cryptpass.so */
	  if (m_query)
	    print_module_config (service_module_list, "pam_cryptpass.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_cryptpass.so", force) != 0)
		return 1;
	      opt_set = mod_pam_cryptpass.get_opt_set (&mod_pam_cryptpass, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 3201:
	  /* pam_cryptpass.so */
	  if (m_query)
	    print_module_config (service_module_list, "pam_cryptpass.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_cryptpass.so", force) != 0)
		return 1;
	      opt_set = mod_pam_cryptpass.get_opt_set (&mod_pam_cryptpass, PASSWORD);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 3300:
	  /* pam_ck_connector.so */
	  if (m_query)
	    print_module_config (service_module_list, "pam_ck_connector.so");
	  else
	    {
	      if (!m_delete && check_for_pam_module ("pam_ck_connector.so", force) != 0)
		return 1;
	      opt_set = mod_pam_ck_connector.get_opt_set (&mod_pam_ck_connector, SESSION);
	      opt_set->enable (opt_set, "is_enabled", opt_val);
	    }
	  break;
	case 3301:
	  opt_set = mod_pam_ck_connector.get_opt_set (&mod_pam_ck_connector, SESSION);
	  opt_set->enable (opt_set, "debug", opt_val);
	  break;
	case 254:
	  debug = 1;
	  break;
	case 255:
          print_help (program);
          return 0;
	case 300:
	  fprintf (stdout,_("Supported common modules:\n"));
	  list_modules (common_module_list);
	  fprintf (stdout,_("\nSupported service modules:\n"));
	  list_modules (service_module_list);
	  return 0;
        case 'v':
          print_version (program, "2007");
          return 0;
        case 'u':
          print_usage (stdout, program);
	  return 0;
	default:
	  print_error (program);
	  return 1;
	}
    }

  argc -= optind;
  argv += optind;

  if (argc > 0)
    {
      fprintf (stderr, _("%s: Too many arguments.\n"), program);
      print_error (program);
      return 1;
    }

  if (m_add + m_create + m_delete + m_init + m_update + m_query != 1)
    {
      print_error (program);
      return 1;
    }


  if (m_query)
    return 0;

  if (m_create)
    {
      /* Set and check sections.  */
      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, ACCOUNT);
      opt_set->enable (opt_set, "is_enabled", TRUE);
      if (sanitize_check_account (common_module_list) != 0)
	return 1;

      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, AUTH);
      opt_set->enable (opt_set, "is_enabled", TRUE);
      if (sanitize_check_auth (common_module_list) != 0)
	return 1;

      opt_set = mod_pam_cracklib.get_opt_set (&mod_pam_cracklib, AUTH);
      if (!opt_set->is_enabled (opt_set, "is_enabled"))
	{
	  opt_set = mod_pam_pwcheck.get_opt_set (&mod_pam_pwcheck, PASSWORD);
	  opt_set->enable (opt_set, "is_enabled", TRUE);
	  opt_set->enable (opt_set, "nullok", TRUE);
	}
      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, PASSWORD);
      opt_set->enable (opt_set, "is_enabled", TRUE);
      opt_set->enable (opt_set, "nullok", TRUE);
      if (sanitize_check_password (common_module_list) != 0)
	return 1;

      opt_set = mod_pam_unix2.get_opt_set (&mod_pam_unix2, SESSION);
      opt_set->enable (opt_set, "is_enabled", opt_val);
      opt_set = mod_pam_limits.get_opt_set (&mod_pam_limits, SESSION);
      opt_set->enable (opt_set, "is_enabled", opt_val);
      opt_set = mod_pam_env.get_opt_set (&mod_pam_env, SESSION);
      opt_set->enable (opt_set, "is_enabled", opt_val);
      opt_set = mod_pam_umask.get_opt_set (&mod_pam_umask, SESSION);
      opt_set->enable (opt_set, "is_enabled", opt_val);
      if (sanitize_check_session (common_module_list) != 0)
	return 1;

	  /* Write sections */
	  if (write_config (ACCOUNT, conf_account_pc, module_list_account) != 0)
		  return 1;

	  if (write_config (AUTH, conf_auth_pc, module_list_auth) != 0)
		  return 1;

	  if (write_config (PASSWORD, conf_password_pc, module_list_password) != 0)
		  return 1;

      if (write_config (SESSION, conf_session_pc, module_list_session) != 0)
	return 1;
    }
  else if (!gl_service)
    {
      /* Check sections.  */
      if (sanitize_check_account (common_module_list) != 0)
	return 1;

      if (sanitize_check_auth (common_module_list) != 0)
	return 1;

      if (sanitize_check_password (common_module_list) != 0)
	return 1;

      if (sanitize_check_session (common_module_list) != 0)
	return 1;

	  /* Write sections.  */
	  if (write_config (ACCOUNT, conf_account_pc, module_list_account) != 0)
		  return 1;

	  if (write_config (AUTH, conf_auth_pc, module_list_auth) != 0)
		  return 1;

	  if (write_config (PASSWORD, conf_password_pc, module_list_password) != 0)
		  return 1;

	  if (write_config (SESSION, conf_session_pc, module_list_session) != 0)
	return 1;
    }
  else
    {
      /* Write new single service files */
      pam_module_t **modptr = service_module_list;

      if (debug)
		  printf ("*** write_config (%s/pam.d/%s)\n", confdir, gl_service);

      /* Check if service file exists */
      char *conffile;
      if (asprintf (&conffile, "%s/pam.d/%s", confdir, gl_service) < 0)
	return 1;

      if (access (conffile, R_OK) != 0)
      {
	fprintf (stderr, _("Cannot access '%s': %m\n"), conffile);
	free (conffile);
	return 1;
      }
      free (conffile);

      while (*modptr != NULL)
	{
	  retval |= (*modptr)->write_config (*modptr, -1, NULL);
	  ++modptr;
	}
    }

  if (m_init || (m_create && force))
    {
		char *bak = NULL;
		if (asprintf (&bak, "%s.pam-config-backup", conf_account) >= 0)
		{
			if (relink (conf_account, conf_account_pc, bak) != 0)
				retval = 1;

			free(bak);
			bak = NULL;

		}
		else
			retval = 1;

		if (asprintf (&bak, "%s.pam-config-backup", conf_auth) >= 0)
		{
			if (relink (conf_auth, conf_auth_pc, bak) != 0)
				retval = 1;

			free(bak);
			bak = NULL;

		}
		else
			retval = 1;


		if (asprintf (&bak, "%s.pam-config-backup", conf_password) >= 0)
		{
			if (relink (conf_password, conf_password_pc, bak) != 0)
				retval = 1;

			free(bak);
			bak = NULL;

		}
		else
			retval = 1;


		if (asprintf (&bak, "%s.pam-config-backup", conf_session) >= 0)
		{
			if (relink (conf_session, conf_session_pc,	bak) != 0)
				retval = 1;

			free(bak);
			bak = NULL;

		}
		else
			retval = 1;


		if (m_init && retval == 0)
		{
			rename ("/etc/security/pam_pwcheck.conf",
					"/etc/security/pam_pwcheck.conf.pam-config-backup");
			rename ("/etc/security/pam_unix2.conf",
					"/etc/security/pam_unix2.conf.pam-config-backup");
		}
		return retval;
    }
  else if (force && !gl_service)
    {
      if (unlink (conf_account) != 0 ||
	  symlink (conf_account_pc, conf_account) != 0)
	{
	  fprintf (stderr,
		   _("Error activating %s (%m)\n"), conf_account);
	  fprintf (stderr,
		   _("New config from %s is not in use!\n"), conf_account_pc);
	  retval = 1;
	}

      if (unlink (conf_auth) != 0 ||
	  symlink (conf_auth_pc, conf_auth) != 0)
	{
	  fprintf (stderr,
		   _("Error activating %s (%m)\n"), conf_auth);
	  fprintf (stderr,
		   _("New config from %s is not in use!\n"), conf_auth_pc);
	  retval = 1;
	}

      if (unlink (conf_password) != 0 ||
	  symlink (conf_password_pc, conf_password) != 0)
	{
	  fprintf (stderr,
		   _("Error activating %s (%m)\n"), conf_password);
	  fprintf (stderr,
		   _("New config from %s is not in use!\n"),
		   conf_password_pc);
	  retval = 1;
	}

      if (unlink (conf_session) != 0 ||
	  symlink (conf_session_pc, conf_session) != 0)
	{
	  fprintf (stderr,
		   _("Error activating %s (%m)\n"), conf_session);
	  fprintf (stderr,
		   _("New config from %s is not in use!\n"),
		   conf_session_pc);
	  retval = 1;
	}
    }

  if (!gl_service)
    {
      if (check_symlink (conf_account_pc, conf_account) != 0)
	retval = 1;
      if (check_symlink (conf_auth_pc, conf_auth) != 0)
	retval = 1;
      if (check_symlink (conf_password_pc, conf_password) != 0)
	retval = 1;
      if (check_symlink (conf_session_pc, conf_session) != 0)
	retval = 1;
    }

  return retval;
}
